#|
This file is a part of ld36
(c) 2016 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
Author: Nicolas Hafner <shinmera@tymoon.eu>, Janne Pakarinen <gingeralesy@gmail.com>
|#

(in-package #:org.shirakumo.fraf.ld36)
(in-readtable :qtools)

(defun internal-time-millis ()
  (/ (get-internal-real-time)
     (/ internal-time-units-per-second
        1000)))

(defclass noise-map ()
  ((noise-map :initform NIL :accessor noise-map)
   (octave :initform NIL :accessor octave)
   (width :initarg :width :accessor width)
   (height :initarg :height :accessor height )))

(defmethod initialize-instance :after ((genmap noise-map) &key (octave 3))
  (setf (octave genmap) octave)
  (regenerate genmap (width genmap) (height genmap)))

(defmethod regenerate ((genmap noise-map) &optional (width -1) (height -1))
  (let* ((start (internal-time-millis))
         (width (if (<= 0 width) width (width genmap)))
         (height (if (<= 0 height) height (height genmap)))
         (map (gen-noise-map width height (octave genmap))))
    (setf (noise-map genmap) map
          (width genmap) width
          (height genmap) height)
    (v:log :debug :map-generator "Generation of the map with octave (~a), and size (~a x ~a) took ~a ms."
           (octave genmap) width height (- (internal-time-millis) start))))

(defmethod locations ((genmap noise-map) zones &key (cluster-size 10) (min-distance 1) filter-locations)
  ;; TODO: instead of defining zones by [0,255] value, use keywords like "rare" and "common", or perhaps a 0-10 scale
  (let ((map (noise-map genmap)))
    (when map
      (let* ((start (internal-time-millis))
             (width (width genmap))
             (height (height genmap))
             (locations))
        (dotimes (x width)
          (dotimes (y height)
            (let ((value (aref map x y))
                  (filters (append locations filter-locations)))
              (when (and (< (count-objects x y min-distance filters) 1)
                         (< (count-objects x y
                                           (ceiling (/ (+ min-distance cluster-size) 2))
                                           filters)
                            cluster-size)
                         (< (random 10) 5))
                (push (cons x y) locations)))))
        (v:log :debug :map-generator "Fetching locations for a map of size (~a x ~a) took ~a ms."
               width height (- (internal-time-millis) start))
        locations))))

(defmethod populate-scene ((genmap noise-map) (scene scene) objects)
  (let ((locations)
        (horiz-offset (floor (/ (width genmap) 2)))
        (depth-offset (floor (/ (height genmap) 2))))
    (for:for ((object in objects))
      ;; 100 and 150 give quite nice results, might try others too.
      ;; Basically 128 is highest chance to appear but tends to bunch things together.
      (let ((object-locations (locations genmap '(100 150) :filter-locations locations)))
        (for:for ((location in object-locations))
          (let ((x (- (first location) horiz-offset))
                (z (- (second location) depth-offset)))
            (enter (make-instance object :location (vec x 0 z)) scene))
          ;; Regenerate to set different kinds of formations for different objects
          (regenerate genmap)
          (nconc locations object-locations))))))


(defun blend-maps (&rest maps)
  (let ((width 0) (height 0))
    (for:for ((map in maps))
      (let ((dimensions (array-dimensions map)))
        (when (< width (first dimensions))
          (setf width (first dimensions)))
        (when (< height (second dimensions))
          (setf height (second dimensions)))))
    (let ((sized-maps))
      (for:for ((map in maps))
        (let ((map-width (first (array-dimensions map)))
              (map-height (second (array-dimensions map))))
          (push
           (if (or (/= width map-width) (/= height map-height))
               (resize-map map width height) map)
           sized-maps)))
      (setf width (1- width)
            height (1- height))
      (let ((new-map (make-array (list width height) :initial-element 0)))
        (dotimes (x width)
          (dotimes (y height)
            (for:for ((map over sized-maps))
              (incf (aref new-map x y) (aref map x y)))
            (setf (aref new-map x y) (floor (/ (aref new-map x y) (length sized-maps))))))
        new-map))))

(defun count-objects (x y distance locations)
  (let* ((double-min (1+ (* 2 distance)))
         (x (- x distance))
         (y (- y distance))
         (counter 0))
    (for:for ((i repeat (* double-min double-min)))
      (let ((x1 (+ x (mod i double-min)))
            (y1 (+ y (floor (/ i double-min)))))
        (for:for ((loc in locations))
          (when (and (= x1 (car loc)) (= y1 (cdr loc)))
            (incf counter)))))
    counter))

(defun gen-noise-map (width height octave)
  (let ((width (1+ width))
        (height (1+ height))
        (medium-blend 4)
        (big-blend 2))
    (blend-maps
     (gen-perlin-noise (gen-whitenoise (ceiling (/ width medium-blend)) (ceiling (/ height medium-blend))) octave)
     (gen-perlin-noise (gen-whitenoise (ceiling (/ width big-blend)) (ceiling (/ height big-blend))) octave)
     (gen-perlin-noise (gen-whitenoise width height) octave))))

(defun gen-whitenoise (width height)
  (let ((noise (make-array (list width height) :initial-element 0)))
    (dotimes (x width)
      (dotimes (y height)
        (setf (aref noise x y) (random 256))))
    noise))

(defun gen-smooth-noise (base-noise octave)
  (let* ((dimensions (array-dimensions base-noise))
         (width (first dimensions))
         (height (second dimensions))
         (smooth-noise (make-array dimensions :initial-element 0))
         (sample-period (ash 1 octave))
         (sample-freq (/ 1.0 sample-period)))
    (dotimes (x width)
      (let* ((sample-x0 (* (floor (/ x sample-period)) sample-period))
             (sample-x1 (mod (+ sample-x0 sample-period) width))
             (horiz-blend (* (- x sample-x0) sample-freq)))
        (dotimes (y height)
          (let* ((sample-y0 (* (floor (/ y sample-period)) sample-period))
                 (sample-y1 (mod (+ sample-y0 sample-period) height))
                 (verti-blend (* (- y sample-y0) sample-freq))
                 (top (interpolate (aref base-noise sample-x0 sample-y0)
                                   (aref base-noise sample-x1 sample-y0)
                                   horiz-blend))
                 (bottom (interpolate (aref base-noise sample-x0 sample-y1)
                                      (aref base-noise sample-x1 sample-y1)
                                      horiz-blend)))
            (setf (aref smooth-noise x y) (floor (interpolate top bottom verti-blend)))))))
    smooth-noise))

(defun gen-perlin-noise (base-noise octave-count)
  (let* ((dimensions (array-dimensions base-noise))
         (width (first dimensions))
         (height (second dimensions))
         (smooth-noises (make-array octave-count :initial-element NIL))
         (persistence 0.5))
    (dotimes (octave octave-count)
      (setf (aref smooth-noises octave) (gen-smooth-noise base-noise octave)))
    (let ((perlin-noise (make-array dimensions :initial-element 0))
          (amplitude 1.0)
          (total-amplitude 0.0))
      (loop for i from (1- octave-count) downto 0 do
            (let ((octave (elt smooth-noises i)))
              (setf amplitude (* amplitude persistence))
              (incf total-amplitude amplitude)
              (dotimes (x width)
                (dotimes (y height)
                  (incf (aref perlin-noise x y) (* (aref octave x y) amplitude))))))
      (dotimes (x width)
        (dotimes (y height)
          (setf (aref perlin-noise x y) (floor (/ (aref perlin-noise x y) total-amplitude)))))
      perlin-noise)))

(defun interpolate (x0 x1 alpha)
  (+ (* x0 (- 1.0 alpha)) (* alpha x1)))

(defun resize-map (map dest-width dest-height)
  (let ((src-width (first (array-dimensions map)))
        (src-height (second (array-dimensions map))))
    (if (and (= src-width dest-width) (= src-height dest-height))
        map
        (let ((diff-x (/ dest-width src-width))
              (diff-y (/ dest-height src-height))
              (dest-map (make-array (list dest-width dest-height) :initial-element -1)))
          (dotimes (x0 src-width)
            (dotimes (y0 src-height)
              (let* ((x1 (mod (1+ x0) src-width))
                     (y1 (mod (1+ y0) src-height))
                     (dest-x (mod (ceiling (* x0 diff-x)) dest-width))
                     (dest-y (mod (ceiling (* y0 diff-y)) dest-height))
                     (current (aref map x0 y0))
                     (far-x (aref map x1 y0))
                     (far-y (aref map x0 y1))
                     (far-xy (aref map x1 y1)))
                (dotimes (i (ceiling diff-x))
                  (let ((mid-x (mod (+ dest-x i) dest-width))
                        (near (interpolate current far-x (/ i diff-x)))
                        (far (interpolate far-y far-xy (/ i diff-x))))
                    ;; wherever you are...
                    (dotimes (j (ceiling diff-y))
                      (let ((mid-y (mod (+ dest-y j) dest-height)))
                        (setf (aref dest-map mid-x mid-y) (interpolate near far (/ j diff-y))))))))))
          dest-map))))
