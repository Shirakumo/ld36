#|
This file is a part of ld36
(c) 2016 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
Author: Nicolas Hafner <shinmera@tymoon.eu>, Janne Pakarinen <gingeralesy@gmail.com>
|#

(in-package #:org.shirakumo.fraf.ld36)
(in-readtable :qtools)

(defun internal-time-millis ()
  (/ (get-internal-real-time)
     (/ internal-time-units-per-second
        1000)))

(defclass noise-map ()
  ((noise-map :initform NIL :accessor noise-map)
   (octave :initform NIL :accessor octave)
   (width :initarg :width :accessor width)
   (height :initarg :height :accessor height)
   (tile-size :initarg :tile-size :accessor tile-size))
  (:default-initargs
   :tile-size 20))

(defmethod initialize-instance :after ((genmap noise-map) &key (octave 3))
  (setf (octave genmap) octave
        (width genmap) (floor (/ (width genmap) (tile-size genmap)))
        (height genmap) (floor (/ (height genmap) (tile-size genmap))))
  (regenerate genmap (width genmap) (height genmap)))

(defmethod regenerate ((genmap noise-map) &optional width height)
  (let* ((start (internal-time-millis))
         (width (or width (width genmap)))
         (height (or height (height genmap)))
         (map (gen-noise-map width height (octave genmap))))
    (setf (noise-map genmap) map
          (width genmap) width
          (height genmap) height)
    (v:log :info :map-generator "Generation of the map with octave (~a), and size (~a x ~a) took ~a ms."
           (octave genmap) width height (- (internal-time-millis) start))))

(defmethod locations ((genmap noise-map) zones &key (cluster-size 10) (min-distance 1) filter-locations limit)
  ;; TODO: instead of defining zones by [0,255] value, use keywords like "rare" and "common", or perhaps a 0-10 scale
  (let ((map (noise-map genmap)))
    (when map
      (let* ((tile-size (tile-size genmap))
             (width (first (array-dimensions map)))
             (height (second (array-dimensions map)))
             (start (internal-time-millis))
             (horiz-offset (floor (/ width 2)))
             (depth-offset (floor (/ height 2)))
             (filters (mapcar #'(lambda (loc)
                                  (cons (/ (+ (car loc) horiz-offset) tile-size)
                                        (/ (+ (cdr loc) depth-offset) tile-size)))
                              filter-locations))
             (locations)
             (counter 0))
        (dotimes (x width)
          (dotimes (y height)
            (let ((value (aref map x y)))
              (when (and (or (not limit) (<= counter limit))
                         (is-good-zone value zones)
                         (< (count-objects x y min-distance filters :limit 1) 1)
                         (< (count-objects x y
                                           (+ min-distance cluster-size)
                                           filters
                                           :limit cluster-size)
                            cluster-size))
                (push (cons x y) filters)
                (push (cons (* (- x horiz-offset) tile-size)
                            (* (- y depth-offset) tile-size)) locations)
                (incf counter)))))
        (v:log :info :map-generator "Fetching locations for a map of size (~a x ~a) took ~a ms."
               width height (- (internal-time-millis) start))
        locations))))

(defmethod populate-scene ((genmap noise-map) (scene scene) objects &key (zones '(200 80)) object-cap filter-locations
                                                                         (min-distance 1) (cluster-size 10))
  ;; About zones, it takes values between [0,255] where 128 is highest chance to appear.
  (let ((start (internal-time-millis))
        (locations filter-locations))
    (for:for ((object in objects))
      (let ((object-locations (locations genmap zones :filter-locations locations
                                                      :min-distance min-distance
                                                      :cluster-size cluster-size
                                                      :limit object-cap)))
        (for:for ((location in object-locations))
          (enter (make-instance object :location (vec (car location) 0 (cdr location))) scene))
        (setf locations (append locations object-locations)))
      ;; Regenerate to set different kinds of formations for different objects
      (regenerate genmap))
    (v:log :info :map-generator "Adding objects to the map of size (~a x ~a) took ~a ms."
           (width genmap) (height genmap) (- (internal-time-millis) start))
    locations))


(defun blend-maps (&rest maps)
  (let ((width 0) (height 0))
    (for:for ((map in maps))
      (let ((dimensions (array-dimensions map)))
        (when (< width (first dimensions))
          (setf width (first dimensions)))
        (when (< height (second dimensions))
          (setf height (second dimensions)))))
    (let ((sized-maps))
      (for:for ((map in maps))
        (let ((map-width (first (array-dimensions map)))
              (map-height (second (array-dimensions map))))
          (push
           (if (or (/= width map-width) (/= height map-height))
               (resize-map map width height) map)
           sized-maps)))
      (setf width (1- width)
            height (1- height))
      (let ((new-map (make-array (list width height) :initial-element 0)))
        (dotimes (x width)
          (dotimes (y height)
            (for:for ((map over sized-maps))
              (incf (aref new-map x y) (aref map x y)))
            (setf (aref new-map x y) (floor (/ (aref new-map x y) (length sized-maps))))))
        new-map))))

(defun count-objects (x y distance locations &key limit)
  (let* ((counter 0)
         (x-min (- x distance))
         (y-min (- y distance))
         (x-max (+ x distance))
         (y-max (+ y distance)))
    (for:for ((loc in locations))
      (let ((x1 (car loc))
            (y1 (cdr loc)))
        (when (and (<= x-min x1 x-max)
                   (<= y-min y1 y-max))
          (incf counter)
          (when (and limit (<= limit counter))
            (return counter)))))
    counter))

(defun gen-noise-map (width height octave)
  (let ((width (1+ width))
        (height (1+ height))
        (medium-blend 4)
        (big-blend 2))
    (blend-maps
     (gen-perlin-noise (gen-whitenoise (ceiling (/ width medium-blend)) (ceiling (/ height medium-blend))) octave)
     (gen-perlin-noise (gen-whitenoise (ceiling (/ width big-blend)) (ceiling (/ height big-blend))) octave)
     (gen-perlin-noise (gen-whitenoise width height) octave))))

(defun gen-whitenoise (width height)
  (let ((noise (make-array (list width height) :initial-element 0)))
    (dotimes (x width)
      (dotimes (y height)
        (setf (aref noise x y) (random 256))))
    noise))

(defun gen-smooth-noise (base-noise octave)
  (let* ((dimensions (array-dimensions base-noise))
         (width (first dimensions))
         (height (second dimensions))
         (smooth-noise (make-array dimensions :initial-element 0))
         (sample-period (ash 1 octave))
         (sample-freq (/ 1.0 sample-period)))
    (dotimes (x width)
      (let* ((sample-x0 (* (floor (/ x sample-period)) sample-period))
             (sample-x1 (mod (+ sample-x0 sample-period) width))
             (horiz-blend (* (- x sample-x0) sample-freq)))
        (dotimes (y height)
          (let* ((sample-y0 (* (floor (/ y sample-period)) sample-period))
                 (sample-y1 (mod (+ sample-y0 sample-period) height))
                 (verti-blend (* (- y sample-y0) sample-freq))
                 (top (interpolate (aref base-noise sample-x0 sample-y0)
                                   (aref base-noise sample-x1 sample-y0)
                                   horiz-blend))
                 (bottom (interpolate (aref base-noise sample-x0 sample-y1)
                                      (aref base-noise sample-x1 sample-y1)
                                      horiz-blend)))
            (setf (aref smooth-noise x y) (floor (interpolate top bottom verti-blend)))))))
    smooth-noise))

(defun gen-perlin-noise (base-noise octave-count)
  (let* ((dimensions (array-dimensions base-noise))
         (width (first dimensions))
         (height (second dimensions))
         (smooth-noises (make-array octave-count :initial-element NIL))
         (persistence 0.5))
    (dotimes (octave octave-count)
      (setf (aref smooth-noises octave) (gen-smooth-noise base-noise octave)))
    (let ((perlin-noise (make-array dimensions :initial-element 0))
          (amplitude 1.0)
          (total-amplitude 0.0))
      (loop for i from (1- octave-count) downto 0 do
            (let ((octave (elt smooth-noises i)))
              (setf amplitude (* amplitude persistence))
              (incf total-amplitude amplitude)
              (dotimes (x width)
                (dotimes (y height)
                  (incf (aref perlin-noise x y) (* (aref octave x y) amplitude))))))
      (dotimes (x width)
        (dotimes (y height)
          (setf (aref perlin-noise x y) (floor (/ (aref perlin-noise x y) total-amplitude)))))
      perlin-noise)))

(defun interpolate (x0 x1 alpha)
  (+ (* x0 (- 1.0 alpha)) (* alpha x1)))

(defun is-good-zone (value zones)
  (let ((fuzzy (* 2 (random 6)))
        (is-good))
    (for:for ((zone in zones))
      (until is-good)
      (setf is-good (<= (abs (- value zone)) fuzzy)))
    is-good))

(defun resize-map (map dest-width dest-height)
  (let ((src-width (first (array-dimensions map)))
        (src-height (second (array-dimensions map))))
    (cond
      ((and (= src-width dest-width) (= src-height dest-height)) map)
      ((< (* src-width src-height) (* dest-width dest-height))
       (let ((diff-x (/ dest-width src-width))
             (diff-y (/ dest-height src-height))
             (dest-map (make-array (list dest-width dest-height) :initial-element -1)))
         (dotimes (x0 src-width)
           (dotimes (y0 src-height)
             (let* ((x1 (mod (1+ x0) src-width))
                    (y1 (mod (1+ y0) src-height))
                    (dest-x (mod (ceiling (* x0 diff-x)) dest-width))
                    (dest-y (mod (ceiling (* y0 diff-y)) dest-height))
                    (current (aref map x0 y0))
                    (far-x (aref map x1 y0))
                    (far-y (aref map x0 y1))
                    (far-xy (aref map x1 y1)))
               (dotimes (i (ceiling diff-x))
                 (let ((mid-x (mod (+ dest-x i) dest-width))
                       (near (interpolate current far-x (/ i diff-x)))
                       (far (interpolate far-y far-xy (/ i diff-x))))
                   ;; wherever you are...
                   (dotimes (j (ceiling diff-y))
                     (let ((mid-y (mod (+ dest-y j) dest-height)))
                       (setf (aref dest-map mid-x mid-y) (interpolate near far (/ j diff-y))))))))))
         dest-map))
      (T
       (let* ((diff-x (/ src-width dest-width))
              (diff-y (/ src-width dest-width))
              (dest-map (make-array (list dest-width dest-height) :initial-element -1))
              (divider (* diff-x diff-y)))
         (for:for ((x from 0 :to dest-width :by diff-x))
           (for:for ((y from 0 :to dest-height :by diff-y))
             (let ((value 0))
               (for:for ((x1 from x :to (+ x diff-x)))
                 (for:for ((y1 from y :to (+ y diff-y)))
                   (incf value (aref map x1 y1))))
               (setf (aref dest-map x y) (/ value divider))))))))))
